import { Options, Message } from "amqplib";
import Exchange from "./Exchange";
import BrokerChannel from "./BrokerChannel";
import ConnectionSetting from "./ConnectionSetting";
import MessageListener from "./MessageListener";
/**
 * I am a queue that simplifies RabbitMQ queues.
 *
 * @author Arkan M. Gerges <arkan.m.gerges@gmail.com>
 */
export default class Queue extends BrokerChannel {
    /**
     * Answers a promise for a new instance of a Queue with a __*name*__. The underlying
     * queue durability, exclusivity, and deletion properties are specified by
     * explicit parameters.
     * @param connectionSetting The ConnectionSetting used to create a queue
     * @param name The name of the queue
     * @param isDurable The boolean indicating whether or not I am durable
     * @param isExclusive The boolean indicating whether or not I am exclusive
     * @param isAutoDeleted The boolean indicating whether or not I should be auto-deleted
     * @return Promise<Queue>
     */
    static customInstanceUsingConnectionSetting(connectionSetting: ConnectionSetting, name: string, isDurable?: boolean, isExclusive?: boolean, isAutoDeleted?: boolean): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue that is bound to an __*exchange*__, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of an *exchange* are reused. The Queue is named
     * by __*name*__, unless it is empty, in which case the name is generated by
     * the broker. The Queue is bound to all routing keys in __*routingKeys*__,
     * or to no routing key if __*routingKeys*__ is empty. The Queue has the
     * qualities specified by isDurable, isExclusive, isAutoDeleted. This
     * factory is provided for ultimate flexibility in case no other
     * exchange-queue binder factories fit the needs of the client.
     * @param exchange the Exchange to bind with the new Queue
     * @param name the name of the queue
     * @param routingKeys the routing keys to bind the queue to
     * @param isDurable the boolean indicating whether or not I am durable
     * @param isExclusive the boolean indicating whether or not I am exclusive
     * @param isAutoDeleted the boolean indicating whether or not I should be auto-deleted
     * @return Promise<Queue>
     */
    static customInstanceUsingExchange(exchange: Exchange, name: string, routingKeys?: string[], isDurable?: boolean, isExclusive?: boolean, isAutoDeleted?: boolean): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue with the name __*name*__. The underlying
     * queue is durable, is non-exclusive, and not auto-deleted.
     * @param connectionSetting The ConnectionSetting used to create the queue
     * @param name The name of the queue
     * @return Promise<Queue>
     */
    static durableInstance(connectionSetting: ConnectionSetting, name: string): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue with the name __*name*__. The underlying
     * queue is durable, exclusive, and not auto-deleted.
     * @param connectionSetting The ConnectionSetting in order to create the queue
     * @param name The name of the queue
     * @return Promise<Queue>
     */
    static durableExclusiveInstance(connectionSetting: ConnectionSetting, name: string): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue with the name __*name*__. The underlying
     * queue is durable, is non-exclusive, and not auto-deleted.
     * @param connectionSetting The ConnectionSetting for creating the queue
     * @param name The name of the queue
     * @return Promise<Queue>
     */
    static durableNonExclusiveNotAutoDeletedInstance(connectionSetting: ConnectionSetting, name: string): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue that is bound to __*exchange*__, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of __*exchange*__ are reused. The Queue is
     * by __*name*__, which must be provided and should be unique to the
     * individual subscriber. The queue is bound to all routing keys in
     * __*routingKeys*__. The Queue is durable, non-exclusive, and is not
     * auto-deleted. This Queue style best works as a durable direct or
     * topic exchange subscriber.
     * @param exchange The exchange to bind with the new Queue
     * @param name The string name of the queue, which must be unique, non-empty
     * @param routingKeys The routing keys to bind the queue to
     * @return Promise<Queue>
     */
    static individualExchangeSubscriberInstance(exchange: Exchange, name: string, routingKeys?: string[]): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue that is bound to __*exchange*__, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of __*exchange*__ are reused. The Queue is
     * uniquely named by the server, non-durable, exclusive, and auto-deleted.
     * This Queue style best works as a temporary fan-out subscriber.
     * @param exchange The Exchange to bind with the new Queue
     * @return Promise<Queue>
     */
    static exchangeTemporarySubscriberInstance(exchange: Exchange): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue that is bound to __*exchange*__, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of __*exchange*__ are reused. The Queue is
     * named by __*name*__, which must be provided and should be unique to the
     * individual subscriber. The Queue is durable, non-exclusive, and
     * is not auto-deleted. This Queue style best works as a durable
     * fan-out exchange subscriber.
     * @param exchange The Exchange to bind with the new Queue
     * @param name The String name of the queue, which must be unique, non-empty
     * @return Promise<Queue>
     */
    static exchangeNamedSubscriberInstance(exchange: Exchange, name: string): Promise<Queue>;
    /**
     * Answers a promise for a new instance of a Queue that is bound to __*exchange*__, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of __*exchange*__ are reused. The Queue is
     * uniquely named by the server, non-durable, exclusive, and auto-deleted.
     * The queue is bound to all routing keys in __*routingKeys*__. This Queue
     * style best works as a temporary direct or topic subscriber.
     * @param exchange The Exchange to bind with the new Queue
     * @param routingKeys The routing keys to bind the queue to
     * @return Promise<Queue>
     */
    static exchangeTemporaryDirectOrTopicSubscriberInstance(exchange: Exchange, routingKeys: string[]): Promise<Queue>;
    /**
     * Consume messages using a __*messageListener*__
     * @param messageListener This is the listener that will handle the messages
     * @param ack This is the callback that is used to acknowledge the message manually
     * @param options The different types of options available for the consumer
     * @return Promise<void>
     */
    consume(messageListener: MessageListener, ack: (message: Message) => void, options?: Options.Consume): Promise<void>;
    /** Close the channel and also the connection for this queue */
    close(): void;
    /**
     * Negative acknowledgment with the possibility to requeue the message
     * @param message The message structure used for negative acknowledgment
     * @param reqeue The boolean to indicate if it is needed to requeue the message
     */
    nack(message: Message, reqeue: boolean): void;
    /**
     * Acknowledge this __*message*__
     * @param message The Message structure that is acknowledged by me
     */
    ack(message: Message): void;
    /**
     * Set a prefetch per channel, which represents the number of messages in the queue
     * that this queue channel can handle.
     * @param count The number of messages that are allowed to be prefeched
     */
    basicQos(count: number): void;
    protected constructor(connectionSetting: ConnectionSetting, brokerChannel: BrokerChannel, name: string);
    private constructQueueAssertion;
}
